{"version":3,"sources":["node_modules/browser-pack/_prelude.js","_dev/js/components/accordion.js","le.js","_dev/js/components/header.js","_dev/js/components/scrolling.js","_dev/js/initializers/accordion.js","_dev/js/initializers/header.js","_dev/js/initializers/scrolling.js","_dev/js/start.js","_dev/js/utils/when-dom-ready.js","node_modules/smoothscroll-polyfill/dist/smoothscroll.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","Accordion","buttons","document","querySelectorAll","forEach","button","addEventListener","event","this","nextElementSibling","classList","toggle","2","HeaderResize","window","header","getElementById","distanceY","pageYOffset","shrinkOn","add","remove","3","SmoothScroll","anchors","run","id","preventDefault","node","target","offsetTop","scroll","top","behavior","anchor","querySelector","4","whenDOMReady","accordionInit","../components/accordion","../utils/when-dom-ready","5","headerInit","../components/header","6","scrollingInit","../components/scrolling","7","polyfill","./initializers/accordion.js","./initializers/header.js","./initializers/scrolling.js","smoothscroll-polyfill","8","isFunction","arg","cb","readyState","attachEvent","9","w","d","undefined","scrollElement","x","y","scrollLeft","scrollTop","ease","k","Math","cos","PI","shouldBailOut","TypeError","findScrollableParent","el","isBody","hasScrollableSpace","hasVisibleOverflow","parentNode","body","clientHeight","scrollHeight","clientWidth","scrollWidth","getComputedStyle","overflow","step","context","frame","requestAnimationFrame","bind","value","currentX","currentY","time","now","elapsed","startTime","SCROLL_TIME","startX","startY","method","scrollable","cancelAnimationFrame","smoothScroll","scrollX","pageXOffset","scrollY","original","documentElement","style","Element","HTMLElement","scrollTo","scrollBy","scrollIntoView","prototype","performance","Date","arguments","left","scrollableParent","parentRects","getBoundingClientRect","clientRects"],"mappings":"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","file":"le.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","function Accordion() {\n    var buttons = document.querySelectorAll('.ef-accordion-container > button');\n    buttons.forEach(function(button) {\n        button.addEventListener('click', function(event) {\n            this.nextElementSibling.classList.toggle('collapsed');\n        });\n    });\n}\n\nmodule.exports = Accordion;\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nfunction Accordion() {\n    var buttons = document.querySelectorAll('.ef-accordion-container > button');\n    buttons.forEach(function(button) {\n        button.addEventListener('click', function(event) {\n            this.nextElementSibling.classList.toggle('collapsed');\n        });\n    });\n}\n\nmodule.exports = Accordion;\n\n},{}],2:[function(require,module,exports){\nfunction HeaderResize() {\n  window.addEventListener('scroll', function(e){\n    var header = document.getElementById(\"header-primary\");\n    // console.log(header);\n    var distanceY = window.pageYOffset;\n    var shrinkOn = 300\n    if (distanceY > shrinkOn) {\n        header.classList.add('smaller');\n\n    } else {\n        header.classList.remove('smaller');\n\n    }\n  }, true);\n}\n\nmodule.exports = HeaderResize;\n\n},{}],3:[function(require,module,exports){\nfunction SmoothScroll() {\n  var anchors = ['home', 'services', 'coaching'];\n\n  var run = function(event, id) {\n    event.preventDefault();\n    var node = document.getElementById(id);\n    var target = (id == 'home')\n      ? 0\n      : node.offsetTop - 85;\n    window.scroll({\n      top: target,\n      behavior: 'smooth'\n    });\n  }\n\n  anchors.forEach(function(anchor) {\n    window.document.querySelector('a[href=\"#' + anchor + '\"]')\n      .addEventListener('click', function(event) {\n        run(event, anchor);\n      });\n  });\n}\n\nmodule.exports = SmoothScroll;\n\n},{}],4:[function(require,module,exports){\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar accordionInit = require('../components/accordion');\n\nwhenDOMReady(function () {\n\n  accordionInit();\n\n});\n\n},{\"../components/accordion\":1,\"../utils/when-dom-ready\":8}],5:[function(require,module,exports){\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar headerInit = require('../components/header');\n\nwhenDOMReady(function () {\n\n  headerInit();\n\n});\n\n},{\"../components/header\":2,\"../utils/when-dom-ready\":8}],6:[function(require,module,exports){\nvar whenDOMReady = require('../utils/when-dom-ready');\nvar scrollingInit = require('../components/scrolling');\n\nwhenDOMReady(function () {\n\n  scrollingInit();\n\n});\n\n},{\"../components/scrolling\":3,\"../utils/when-dom-ready\":8}],7:[function(require,module,exports){\n'use strict';\n\nrequire('smoothscroll-polyfill').polyfill();\n\nrequire('./initializers/header.js');\nrequire('./initializers/scrolling.js');\nrequire('./initializers/accordion.js');\n\n\n},{\"./initializers/accordion.js\":4,\"./initializers/header.js\":5,\"./initializers/scrolling.js\":6,\"smoothscroll-polyfill\":9}],8:[function(require,module,exports){\n/*\n * @name DOMLoaded\n * @param {function} cb - The callback function to run when the DOM has loaded.\n */\nmodule.exports = function DOMLoaded (cb) {\n  // in case the document is already rendered\n  if ('loading' !== document.readyState) {\n    if (isFunction(cb)) {\n      cb();\n    }\n  } else if (document.addEventListener) { // modern browsers\n    document.addEventListener('DOMContentLoaded', cb);\n  } else { // IE <= 8\n    document.attachEvent('onreadystatechange', function (){\n      if ('complete' === document.readyState) {\n        if (isFunction(cb)) {\n          cb();\n        }\n      }\n    });\n  }\n};\n\nfunction isFunction (arg) {\n  return (typeof arg === 'function');\n}\n\n},{}],9:[function(require,module,exports){\n/*\n * smoothscroll polyfill - v0.3.4\n * https://iamdustan.github.io/smoothscroll\n * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License\n */\n\n(function(w, d, undefined) {\n  'use strict';\n\n  /*\n   * aliases\n   * w: window global object\n   * d: document\n   * undefined: undefined\n   */\n\n  // polyfill\n  function polyfill() {\n    // return when scrollBehavior interface is supported\n    if ('scrollBehavior' in d.documentElement.style) {\n      return;\n    }\n\n    /*\n     * globals\n     */\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    /*\n     * object gathering original scroll methods\n     */\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    /*\n     * define timing method\n     */\n    var now = w.performance && w.performance.now\n      ? w.performance.now.bind(w.performance) : Date.now;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} x\n     * @returns {Boolean}\n     */\n    function shouldBailOut(x) {\n      if (typeof x !== 'object'\n            || x === null\n            || x.behavior === undefined\n            || x.behavior === 'auto'\n            || x.behavior === 'instant') {\n        // first arg not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof x === 'object'\n            && x.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError('behavior not valid');\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      var isBody;\n      var hasScrollableSpace;\n      var hasVisibleOverflow;\n\n      do {\n        el = el.parentNode;\n\n        // set condition variables\n        isBody = el === d.body;\n        hasScrollableSpace =\n          el.clientHeight < el.scrollHeight ||\n          el.clientWidth < el.scrollWidth;\n        hasVisibleOverflow =\n          w.getComputedStyle(el, null).overflow === 'visible';\n      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));\n\n      isBody = hasScrollableSpace = hasVisibleOverflow = null;\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     */\n    function step(context) {\n      // call method again on next available frame\n      context.frame = w.requestAnimationFrame(step.bind(w, context));\n\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // return when end points have been reached\n      if (currentX === context.x && currentY === context.y) {\n        w.cancelAnimationFrame(context.frame);\n        return;\n      }\n    }\n\n    /**\n     * scrolls window with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n      var frame;\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // cancel frame when a scroll event's happening\n      if (frame) {\n        w.cancelAnimationFrame(frame);\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y,\n        frame: frame\n      });\n    }\n\n    /*\n     * ORIGINAL METHODS OVERRIDES\n     */\n\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scroll.call(\n          w,\n          arguments[0].left || arguments[0],\n          arguments[0].top || arguments[1]\n        );\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left,\n        ~~arguments[0].top\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left || arguments[0],\n          arguments[0].top || arguments[1]\n        );\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollIntoView.call(this, arguments[0] || true);\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n        // reveal parent in viewport\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: 'smooth'\n        });\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n})(window, document);\n\n},{}]},{},[7])\n\n","function HeaderResize() {\n  window.addEventListener('scroll', function(e){\n    var header = document.getElementById(\"header-primary\");\n    // console.log(header);\n    var distanceY = window.pageYOffset;\n    var shrinkOn = 300\n    if (distanceY > shrinkOn) {\n        header.classList.add('smaller');\n\n    } else {\n        header.classList.remove('smaller');\n\n    }\n  }, true);\n}\n\nmodule.exports = HeaderResize;\n","function SmoothScroll() {\n  var anchors = ['home', 'services', 'coaching'];\n\n  var run = function(event, id) {\n    event.preventDefault();\n    var node = document.getElementById(id);\n    var target = (id == 'home')\n      ? 0\n      : node.offsetTop - 85;\n    window.scroll({\n      top: target,\n      behavior: 'smooth'\n    });\n  }\n\n  anchors.forEach(function(anchor) {\n    window.document.querySelector('a[href=\"#' + anchor + '\"]')\n      .addEventListener('click', function(event) {\n        run(event, anchor);\n      });\n  });\n}\n\nmodule.exports = SmoothScroll;\n","var whenDOMReady = require('../utils/when-dom-ready');\nvar accordionInit = require('../components/accordion');\n\nwhenDOMReady(function () {\n\n  accordionInit();\n\n});\n","var whenDOMReady = require('../utils/when-dom-ready');\nvar headerInit = require('../components/header');\n\nwhenDOMReady(function () {\n\n  headerInit();\n\n});\n","var whenDOMReady = require('../utils/when-dom-ready');\nvar scrollingInit = require('../components/scrolling');\n\nwhenDOMReady(function () {\n\n  scrollingInit();\n\n});\n","'use strict';\n\nrequire('smoothscroll-polyfill').polyfill();\n\nrequire('./initializers/header.js');\nrequire('./initializers/scrolling.js');\nrequire('./initializers/accordion.js');\n\n","/*\n * @name DOMLoaded\n * @param {function} cb - The callback function to run when the DOM has loaded.\n */\nmodule.exports = function DOMLoaded (cb) {\n  // in case the document is already rendered\n  if ('loading' !== document.readyState) {\n    if (isFunction(cb)) {\n      cb();\n    }\n  } else if (document.addEventListener) { // modern browsers\n    document.addEventListener('DOMContentLoaded', cb);\n  } else { // IE <= 8\n    document.attachEvent('onreadystatechange', function (){\n      if ('complete' === document.readyState) {\n        if (isFunction(cb)) {\n          cb();\n        }\n      }\n    });\n  }\n};\n\nfunction isFunction (arg) {\n  return (typeof arg === 'function');\n}\n","/*\n * smoothscroll polyfill - v0.3.4\n * https://iamdustan.github.io/smoothscroll\n * 2016 (c) Dustan Kasten, Jeremias Menichelli - MIT License\n */\n\n(function(w, d, undefined) {\n  'use strict';\n\n  /*\n   * aliases\n   * w: window global object\n   * d: document\n   * undefined: undefined\n   */\n\n  // polyfill\n  function polyfill() {\n    // return when scrollBehavior interface is supported\n    if ('scrollBehavior' in d.documentElement.style) {\n      return;\n    }\n\n    /*\n     * globals\n     */\n    var Element = w.HTMLElement || w.Element;\n    var SCROLL_TIME = 468;\n\n    /*\n     * object gathering original scroll methods\n     */\n    var original = {\n      scroll: w.scroll || w.scrollTo,\n      scrollBy: w.scrollBy,\n      scrollIntoView: Element.prototype.scrollIntoView\n    };\n\n    /*\n     * define timing method\n     */\n    var now = w.performance && w.performance.now\n      ? w.performance.now.bind(w.performance) : Date.now;\n\n    /**\n     * changes scroll position inside an element\n     * @method scrollElement\n     * @param {Number} x\n     * @param {Number} y\n     */\n    function scrollElement(x, y) {\n      this.scrollLeft = x;\n      this.scrollTop = y;\n    }\n\n    /**\n     * returns result of applying ease math function to a number\n     * @method ease\n     * @param {Number} k\n     * @returns {Number}\n     */\n    function ease(k) {\n      return 0.5 * (1 - Math.cos(Math.PI * k));\n    }\n\n    /**\n     * indicates if a smooth behavior should be applied\n     * @method shouldBailOut\n     * @param {Number|Object} x\n     * @returns {Boolean}\n     */\n    function shouldBailOut(x) {\n      if (typeof x !== 'object'\n            || x === null\n            || x.behavior === undefined\n            || x.behavior === 'auto'\n            || x.behavior === 'instant') {\n        // first arg not an object/null\n        // or behavior is auto, instant or undefined\n        return true;\n      }\n\n      if (typeof x === 'object'\n            && x.behavior === 'smooth') {\n        // first argument is an object and behavior is smooth\n        return false;\n      }\n\n      // throw error when behavior is not supported\n      throw new TypeError('behavior not valid');\n    }\n\n    /**\n     * finds scrollable parent of an element\n     * @method findScrollableParent\n     * @param {Node} el\n     * @returns {Node} el\n     */\n    function findScrollableParent(el) {\n      var isBody;\n      var hasScrollableSpace;\n      var hasVisibleOverflow;\n\n      do {\n        el = el.parentNode;\n\n        // set condition variables\n        isBody = el === d.body;\n        hasScrollableSpace =\n          el.clientHeight < el.scrollHeight ||\n          el.clientWidth < el.scrollWidth;\n        hasVisibleOverflow =\n          w.getComputedStyle(el, null).overflow === 'visible';\n      } while (!isBody && !(hasScrollableSpace && !hasVisibleOverflow));\n\n      isBody = hasScrollableSpace = hasVisibleOverflow = null;\n\n      return el;\n    }\n\n    /**\n     * self invoked function that, given a context, steps through scrolling\n     * @method step\n     * @param {Object} context\n     */\n    function step(context) {\n      // call method again on next available frame\n      context.frame = w.requestAnimationFrame(step.bind(w, context));\n\n      var time = now();\n      var value;\n      var currentX;\n      var currentY;\n      var elapsed = (time - context.startTime) / SCROLL_TIME;\n\n      // avoid elapsed times higher than one\n      elapsed = elapsed > 1 ? 1 : elapsed;\n\n      // apply easing to elapsed time\n      value = ease(elapsed);\n\n      currentX = context.startX + (context.x - context.startX) * value;\n      currentY = context.startY + (context.y - context.startY) * value;\n\n      context.method.call(context.scrollable, currentX, currentY);\n\n      // return when end points have been reached\n      if (currentX === context.x && currentY === context.y) {\n        w.cancelAnimationFrame(context.frame);\n        return;\n      }\n    }\n\n    /**\n     * scrolls window with a smooth behavior\n     * @method smoothScroll\n     * @param {Object|Node} el\n     * @param {Number} x\n     * @param {Number} y\n     */\n    function smoothScroll(el, x, y) {\n      var scrollable;\n      var startX;\n      var startY;\n      var method;\n      var startTime = now();\n      var frame;\n\n      // define scroll context\n      if (el === d.body) {\n        scrollable = w;\n        startX = w.scrollX || w.pageXOffset;\n        startY = w.scrollY || w.pageYOffset;\n        method = original.scroll;\n      } else {\n        scrollable = el;\n        startX = el.scrollLeft;\n        startY = el.scrollTop;\n        method = scrollElement;\n      }\n\n      // cancel frame when a scroll event's happening\n      if (frame) {\n        w.cancelAnimationFrame(frame);\n      }\n\n      // scroll looping over a frame\n      step({\n        scrollable: scrollable,\n        method: method,\n        startTime: startTime,\n        startX: startX,\n        startY: startY,\n        x: x,\n        y: y,\n        frame: frame\n      });\n    }\n\n    /*\n     * ORIGINAL METHODS OVERRIDES\n     */\n\n    // w.scroll and w.scrollTo\n    w.scroll = w.scrollTo = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scroll.call(\n          w,\n          arguments[0].left || arguments[0],\n          arguments[0].top || arguments[1]\n        );\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left,\n        ~~arguments[0].top\n      );\n    };\n\n    // w.scrollBy\n    w.scrollBy = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollBy.call(\n          w,\n          arguments[0].left || arguments[0],\n          arguments[0].top || arguments[1]\n        );\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      smoothScroll.call(\n        w,\n        d.body,\n        ~~arguments[0].left + (w.scrollX || w.pageXOffset),\n        ~~arguments[0].top + (w.scrollY || w.pageYOffset)\n      );\n    };\n\n    // Element.prototype.scrollIntoView\n    Element.prototype.scrollIntoView = function() {\n      // avoid smooth behavior if not required\n      if (shouldBailOut(arguments[0])) {\n        original.scrollIntoView.call(this, arguments[0] || true);\n        return;\n      }\n\n      // LET THE SMOOTHNESS BEGIN!\n      var scrollableParent = findScrollableParent(this);\n      var parentRects = scrollableParent.getBoundingClientRect();\n      var clientRects = this.getBoundingClientRect();\n\n      if (scrollableParent !== d.body) {\n        // reveal element inside parent\n        smoothScroll.call(\n          this,\n          scrollableParent,\n          scrollableParent.scrollLeft + clientRects.left - parentRects.left,\n          scrollableParent.scrollTop + clientRects.top - parentRects.top\n        );\n        // reveal parent in viewport\n        w.scrollBy({\n          left: parentRects.left,\n          top: parentRects.top,\n          behavior: 'smooth'\n        });\n      } else {\n        // reveal element in viewport\n        w.scrollBy({\n          left: clientRects.left,\n          top: clientRects.top,\n          behavior: 'smooth'\n        });\n      }\n    };\n  }\n\n  if (typeof exports === 'object') {\n    // commonjs\n    module.exports = { polyfill: polyfill };\n  } else {\n    // global\n    polyfill();\n  }\n})(window, document);\n"]}